const SENSITIVE_TITLE_WORDS = [
  "password","passwd","passphrase",
  "shared secret","secret","psk","token","api key","apikey","access key",
  "private key","certificate","cert","csr","pem","fingerprint","thumbprint",
  "radius secret","tacacs secret","key:*","confirm key"
];

function lower(s){ return String(s||"").toLowerCase(); }

function looksAutoGenerated(s) {
  if (!s) return true;
  const t = String(s).trim();
  if (!t) return true;
  if (/^x-auto-\d+/.test(t)) return true;
  if (/x-auto-\d+__/.test(t)) return true;
  if (/^css-[a-z0-9]{4,}$/i.test(t)) return true;
  if (t === "UI element" || t === "(unlabeled control)" || t === "content" || t === "Link" || t === "Button" || t === "Field") return true;
  if (t.includes(">") && t.length > 20) return true;
  return false;
}

function isSensitiveTitle(s) {
  const t = lower(s);
  return SENSITIVE_TITLE_WORDS.some(w => t.includes(String(w).toLowerCase()));
}

function cleanTitle(s, fallback="(unlabeled control)") {
  if (!s) return fallback;
  let t = String(s).trim();
  t = t.replace(/^\s*(click|set|change|input|navigate|nav)\s*:\s*/i, "");
  t = t.replace(/\s+/g, " ").trim();
  if (/x-auto-\d+/i.test(t)) return fallback;
  t = t.replace(/\s*[:*]+\s*$/g, "").trim();
  if (!t) return fallback;
  if (looksAutoGenerated(t)) return fallback;
  if (isSensitiveTitle(t)) return "(sensitive field)";
  return t;
}

function titleFor(ev) {
  if (!ev) return "Step";
  if (ev.editedTitle) return ev.editedTitle;
  const raw = ev.human || ev.label || ev.text || ev.actionKind || ev.tag || "";
  const name = cleanTitle(raw);

  if (ev.type === "click") return `${name}`;
  if (ev.type === "input") return `Type in ${name}`;
  if (ev.type === "change") {
    if (ev.checked !== null && ev.checked !== undefined) return `Set ${name} to ${ev.checked ? "ON" : "OFF"}`;
    return `Set ${name} to "${ev.value || ""}"`;
  }
  if (ev.type === "submit") return `Submit: ${name}`;
  if (ev.type === "nav") return `Navigate: ${name}`;
  if (ev.type === "note") return "Note";
  if (ev.type === "outcome") return `Outcome: ${ev.outcome || ""}`;
  return cleanTitle(ev.type || "Step", "Step");
}

function el(tag, cls, text) {
  const n = document.createElement(tag);
  if (cls) n.className = cls;
  if (text !== undefined) n.textContent = text;
  return n;
}

async function saveReports(reports) {
  await browser.storage.local.set({ reports });
}

function filterEvents(events, query, typeFilter, urlFilter) {
  const q = lower(query || "");
  const uf = lower(urlFilter || "");
  return events.filter(ev => {
    if (typeFilter && typeFilter !== "all" && ev.type !== typeFilter) return false;
    if (uf && !lower(ev.url || "").includes(uf)) return false;
    if (!q) return true;
    const hay = [ev.url, ev.label, ev.text, ev.human, ev.value, ev.outcome].join(" ");
    return lower(hay).includes(q);
  });
}

function buildHints(events) {
  const fields = new Set();
  const buttons = new Set();
  events.forEach(ev => {
    if (ev.type === "input" || ev.type === "change") {
      const t = cleanTitle(ev.label || ev.human || "");
      if (t) fields.add(t);
    }
    if (ev.type === "click" || ev.type === "submit") {
      const t = cleanTitle(ev.label || ev.human || ev.text || "");
      if (t) buttons.add(t);
    }
  });
  return { fields: Array.from(fields), buttons: Array.from(buttons) };
}

function renderHints(target, events) {
  const hints = buildHints(events);
  target.innerHTML = "";
  const list = el("div", "hint-list");
  hints.fields.forEach(f => list.appendChild(el("div", "chip", `Field: ${f}`)));
  hints.buttons.forEach(b => list.appendChild(el("div", "chip", `Action: ${b}`)));
  if (!hints.fields.length && !hints.buttons.length) {
    target.appendChild(el("div", "hint", "No hints yet."));
  } else {
    target.appendChild(list);
  }
}

function renderTimeline(target, events) {
  target.innerHTML = "";
  const byTab = new Map();
  events.forEach(ev => {
    const key = ev.tabId !== null && ev.tabId !== undefined ? `Tab ${ev.tabId}` : "Tab";
    if (!byTab.has(key)) byTab.set(key, []);
    byTab.get(key).push(ev);
  });
  const tabs = Array.from(byTab.keys());
  target.style.gridTemplateColumns = `repeat(${Math.max(1, tabs.length)}, minmax(180px, 1fr))`;
  tabs.forEach(key => {
    const col = el("div", "timeline-column");
    const title = byTab.get(key)[0] && byTab.get(key)[0].tabTitle ? byTab.get(key)[0].tabTitle : key;
    col.appendChild(el("div", "timeline-header", title));
    byTab.get(key).forEach(ev => {
      const block = el("div", "timeline-event");
      block.textContent = `${ev.type || "event"} — ${titleFor(ev)}`;
      col.appendChild(block);
    });
    target.appendChild(col);
  });
}

function hexToRgba(hex, alpha) {
  const h = hex.replace("#", "");
  const r = parseInt(h.substring(0, 2), 16) || 0;
  const g = parseInt(h.substring(2, 4), 16) || 0;
  const b = parseInt(h.substring(4, 6), 16) || 0;
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function setupAnnotationTools(canvas, ev, report, reports, idx, root) {
  const ctx = canvas.getContext("2d");
  const state = {
    mode: "pen",
    color: "#ff3b3b",
    size: 3,
    drawing: false,
    startX: 0,
    startY: 0,
    history: []
  };

  function pushHistory() {
    try { state.history.push(canvas.toDataURL()); } catch (_) {}
    if (state.history.length > 20) state.history.shift();
  }

  function restoreFromHistory() {
    const last = state.history.pop();
    if (!last) return;
    const img = new Image();
    img.onload = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    };
    img.src = last;
  }

  canvas.addEventListener("mousedown", (e) => {
    state.drawing = true;
    const rect = canvas.getBoundingClientRect();
    state.startX = e.clientX - rect.left;
    state.startY = e.clientY - rect.top;
    if (state.mode === "pen") {
      ctx.strokeStyle = state.color;
      ctx.lineWidth = state.size;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(state.startX, state.startY);
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (!state.drawing) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (state.mode === "pen") {
      ctx.lineTo(x, y);
      ctx.stroke();
    }
  });

  canvas.addEventListener("mouseup", (e) => {
    if (!state.drawing) return;
    state.drawing = false;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (state.mode === "rect" || state.mode === "highlight" || state.mode === "outline") {
      const w = x - state.startX;
      const h = y - state.startY;
      if (state.mode === "outline") {
        ctx.strokeStyle = state.color;
        ctx.lineWidth = Math.max(2, state.size);
        ctx.strokeRect(state.startX, state.startY, w, h);
      } else {
        ctx.fillStyle = state.mode === "highlight" ? hexToRgba(state.color, 0.25) : state.color;
        ctx.fillRect(state.startX, state.startY, w, h);
      }
    }
    if (state.mode === "text") {
      const text = window.prompt("Text:");
      if (text) {
        ctx.fillStyle = state.color;
        ctx.font = `${Math.max(12, state.size * 4)}px sans-serif`;
        ctx.fillText(text, state.startX, state.startY);
      }
    }
    pushHistory();
    ev.annotation = canvas.toDataURL();
    saveReports(reports);
  });

  return {
    setMode: (m) => { state.mode = m; },
    setColor: (c) => { state.color = c; },
    setSize: (s) => { state.size = s; },
    clear: () => { ctx.clearRect(0, 0, canvas.width, canvas.height); state.history = []; ev.annotation = ""; saveReports(reports); },
    undo: () => restoreFromHistory(),
    load: (dataUrl) => {
      if (!dataUrl) return;
      const img = new Image();
      img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      img.src = dataUrl;
    }
  };
}

function buildExportHtml(report) {
  const title = "UI Workflow Report";
  const rows = (report.events || []).map((ev, i) => {
    const stepTitle = titleFor(ev);
    const img = ev.screenshot ? `<div class="shot"><img src="${ev.screenshot}"></div>` : "";
    const ann = ev.annotation ? `<img class="annot" src="${ev.annotation}">` : "";
    const wrap = ev.screenshot ? `<div class="shot-wrap">${img}${ann}</div>` : "";
    return `<div class="step"><div class="step-title">${i + 1}. ${stepTitle}</div><div class="step-meta">${ev.ts || ""} — ${ev.url || ""}</div>${wrap}</div>`;
  }).join("\n");

  return `<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>${title}</title>
<style>
body{font-family:Arial,sans-serif;margin:18px;color:#111;background:#fff}
.step{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
.step-title{font-weight:bold;margin-bottom:6px}
.step-meta{font-size:12px;color:#666;margin-bottom:8px}
.shot-wrap{position:relative;display:inline-block}
.shot img{max-width:100%;border:1px solid #ddd;border-radius:10px}
.annot{position:absolute;left:0;top:0;width:100%;height:100%}
</style></head><body>
<h1>${title}</h1>
${rows}
</body></html>`;
}

document.addEventListener("DOMContentLoaded", async () => {
  const params = new URLSearchParams(location.search);
  const isPrint = params.get("print") === "1";
  const idxParam = params.get("idx");
  if (isPrint) document.body.classList.add("print");

  const stored = await browser.storage.local.get(["reports"]);
  const reports = Array.isArray(stored.reports) ? stored.reports : [];
  const root = document.getElementById("steps");
  const select = document.getElementById("report-select");
  const search = document.getElementById("search");
  const typeFilter = document.getElementById("type-filter");
  const urlFilter = document.getElementById("url-filter");
  const hints = document.getElementById("hints");
  const timeline = document.getElementById("timeline");
  const bundleBtn = document.getElementById("bundle");

  const idx = Math.max(0, Math.min(reports.length - 1, Number(idxParam || 0)));
  const report = reports[idx];

  const shownAt = report && report.createdAt ? new Date(report.createdAt).toLocaleString() : "n/a";
  const shownSteps = report && Array.isArray(report.events) ? report.events.length : 0;
  const sess = report && report.sessionId ? report.sessionId : "n/a";
  document.getElementById("meta").textContent =
    `Saved reports: ${reports.length} | Showing: ${shownAt} | Steps: ${shownSteps} | Session: ${sess}`;

  if (select) {
    select.innerHTML = "";
    reports.forEach((r, i) => {
      const opt = document.createElement("option");
      const label = `${i + 1}. ${new Date(r.createdAt || Date.now()).toLocaleString()} (${(r.events || []).length} steps)`;
      opt.value = String(i);
      opt.textContent = label;
      if (i === idx) opt.selected = true;
      select.appendChild(opt);
    });
    select.addEventListener("change", () => {
      const next = select.value || "0";
      const url = new URL(location.href);
      url.searchParams.set("idx", next);
      if (isPrint) url.searchParams.set("print", "1");
      location.href = url.toString();
    });
  }

  if (!reports.length || !report || !Array.isArray(report.events) || !report.events.length) {
    root.appendChild(el("p", null, "No saved reports yet. Record a workflow and press Stop to save it."));
    return;
  }

  function updateAux() {
    renderHints(hints, report.events);
    renderTimeline(timeline, report.events);
  }

  function render() {
    root.innerHTML = "";
    const events = filterEvents(report.events, search.value, typeFilter.value, urlFilter.value);
    updateAux();

    events.forEach((ev, index) => {
      const wrap = el("div", "step");
      const title = el("div", "step-title");
      const idxSpan = el("span", "step-index", `${index + 1}. `);
      const titleSpan = el("span", "step-title-text", titleFor(ev));
      titleSpan.contentEditable = "true";
      titleSpan.addEventListener("blur", async () => {
        ev.editedTitle = titleSpan.textContent.trim();
        await saveReports(reports);
        updateAux();
      });
      title.appendChild(idxSpan);
      title.appendChild(titleSpan);
      if (ev.actionHint) {
        title.appendChild(el("span", "badge", ev.actionHint));
      }
      if (ev.prunedCount) {
        title.appendChild(el("span", "badge", `condensed x${ev.prunedCount}`));
      }
      wrap.appendChild(title);

      const tabLabel = ev.tabId !== null && ev.tabId !== undefined ? `Tab ${ev.tabId}` : "Tab";
      const metaText = `${ev.ts || ""} — ${ev.url || ""} — ${tabLabel}`;
      wrap.appendChild(el("div", "step-meta", metaText));

      const actions = el("div", "step-actions noprint");
      const deleteStep = el("button", "btn danger", "Delete step");
      deleteStep.addEventListener("click", async () => {
        const pos = report.events.indexOf(ev);
        if (pos >= 0) report.events.splice(pos, 1);
        await saveReports(reports);
        render();
      });
      actions.appendChild(deleteStep);

      if (ev.screenshot) {
        const removeShot = el("button", "btn", "Remove screenshot");
        removeShot.addEventListener("click", async () => {
          ev.screenshot = null;
          ev.screenshotSkipped = true;
          ev.screenshotSkipReason = "removed";
          await saveReports(reports);
          render();
        });
        actions.appendChild(removeShot);
      }
      wrap.appendChild(actions);

      if (ev.type === "note") {
        const note = el("div", "step-note", ev.text || "");
        note.contentEditable = "true";
        note.addEventListener("blur", async () => {
          ev.text = note.textContent.trim();
          await saveReports(reports);
          updateAux();
        });
        wrap.appendChild(note);
      }

      if (ev.screenshot) {
        const shotWrap = el("div", "shot-wrap");
        const img = document.createElement("img");
        img.className = "step-img";
        img.src = ev.screenshot;
        shotWrap.appendChild(img);

        const canvas = document.createElement("canvas");
        canvas.className = "shot-canvas";
        shotWrap.appendChild(canvas);

        const tools = el("div", "annot-tools noprint");
        const mode = document.createElement("select");
        ["pen","rect","outline","highlight","text"].forEach(m => {
          const opt = document.createElement("option");
          opt.value = m;
          opt.textContent = m;
          mode.appendChild(opt);
        });
        const color = document.createElement("input");
        color.type = "color";
        color.value = "#ff3b3b";
        const size = document.createElement("input");
        size.type = "range";
        size.min = "1";
        size.max = "8";
        size.value = "3";
        const undoBtn = el("button", "btn", "Undo");
        const clearBtn = el("button", "btn", "Clear");
        tools.appendChild(mode);
        tools.appendChild(color);
        tools.appendChild(size);
        tools.appendChild(undoBtn);
        tools.appendChild(clearBtn);

        img.onload = () => {
          const w = img.clientWidth || img.naturalWidth;
          const h = img.clientHeight || img.naturalHeight;
          canvas.width = w;
          canvas.height = h;
          canvas.style.width = `${w}px`;
          canvas.style.height = `${h}px`;
          const annot = setupAnnotationTools(canvas, ev, report, reports, index, root);
          annot.setMode(mode.value);
          annot.setColor(color.value);
          annot.setSize(Number(size.value));
          if (ev.annotation) annot.load(ev.annotation);

          mode.addEventListener("change", () => annot.setMode(mode.value));
          color.addEventListener("change", () => annot.setColor(color.value));
          size.addEventListener("change", () => annot.setSize(Number(size.value)));
          undoBtn.addEventListener("click", () => annot.undo());
          clearBtn.addEventListener("click", () => annot.clear());
        };

        wrap.appendChild(tools);
        wrap.appendChild(shotWrap);
      } else if (ev.screenshotSkipped) {
        wrap.appendChild(el("div", "step-note", `Screenshot skipped (${ev.screenshotSkipReason || "n/a"}).`));
      }
      root.appendChild(wrap);
    });
  }

  render();
  if (search) search.addEventListener("input", render);
  if (typeFilter) typeFilter.addEventListener("change", render);
  if (urlFilter) urlFilter.addEventListener("input", render);

  if (bundleBtn) {
    bundleBtn.addEventListener("click", async () => {
      const html = buildExportHtml(report);
      const blob = new Blob([html], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const filename = `ui-report-${new Date().toISOString().replace(/[:.]/g, "-")}.html`;
      await browser.downloads.download({ url, filename, saveAs: true });
      setTimeout(() => URL.revokeObjectURL(url), 30_000);
    });
  }

  if (isPrint) setTimeout(() => window.print(), 450);
});
